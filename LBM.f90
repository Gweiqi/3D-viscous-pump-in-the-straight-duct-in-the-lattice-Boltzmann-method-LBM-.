!
!  LBM.f90
!
!  Free-Format Fortran Source File 
!  Generated by PGI Visual Fortran(R)
!  1/19/2017 2:09:26 PM
!
    Module LBM
        use DataType 
		use Geo              

		interface Bounce_Back
          module procedure Bounce_Back_D3Q15
		end interface

		interface distribution_initialaize
          module procedure distribution_initialaize_D3Q15
		end interface

		interface LB_Stream
          module procedure LB_Stream_D3Q15
		end interface
    Contains
        !*************************
        subroutine distribution_allocation(info,distribution_now,distribution_next,eq_distribution,delta_x,delta_t,tau,concept,Q_lattice,distribution_WallBC)
        implicit none
              !--- IN
              real (RK), intent(IN) :: delta_t,tau,delta_x
              Character (len=30), intent(in) :: concept
			  integer,intent(in):: Q_lattice
              !--- IN/OUT
              type(DistroFunction), Intent(INOUT) ::info 
              real (RK), allocatable, intent(INOUT):: distribution_now(:,:,:,:), distribution_next(:,:,:,:),eq_distribution(:,:,:,:)
              type(Wall_info), allocatable, intent(INOUT)::distribution_WallBC(:,:,:)
              !--- local
              integer :: AllocateStatus
			  

              info%concept=concept          
              info%delta_t=delta_t
              info%tau=tau
              info%C=delta_x/delta_t
              info%C2=info%C*info%C
              info%C4=info%C2*info%C2
              info%Cs2=info%C*info%C/3.0_RK
              
              allocate (distribution_now(0:nx-1,0:ny-1,0:nz-1,0:Q_lattice),distribution_next(0:nx-1,0:ny-1,0:nz-1,0:Q_lattice), STAT = AllocateStatus)
              IF (AllocateStatus /= 0) STOP "*** Not enough memory - distribution ***"
              distribution_now=0.0_RK
			  distribution_next=0.0_RK
              
              allocate (eq_distribution(0:nx-1,0:ny-1,0:nz-1,0:Q_lattice), STAT = AllocateStatus)
              IF (AllocateStatus /= 0) STOP "*** Not enough memory - eq_distribution ***"
              eq_distribution=0.0_RK  
              
               allocate (distribution_WallBC(0:nx-1,0:ny-1,0:nz-1), STAT = AllocateStatus)
              IF (AllocateStatus /= 0) STOP "*** Not enough memory - WallBC ***"
          return   
          end subroutine 
        !**********************
        subroutine distribution_display(info)
        implicit none
        !--- IN
        type(DistroFunction), intent(in) ::info
        print*;
        print*,' Concept: ',trim(adjustl(info%concept)) 
        print*,' delta t:',info%delta_t
        print*,' tau    :',info%tau
        print*,' C      :',info%C
        print*,' Cs2    :',info%Cs2
        print*;
        end subroutine
        !************************
        Subroutine LB_Stream_D3Q15(distribution_now,distribution_next,lattice_in)
        implicit none
		!--- In
		type(Latice_D3Q15),intent(in):: lattice_in
        Real (RK), intent(IN):: distribution_now(0:nx-1,0:ny-1,0:nz-1,0:lattice_in%Q) 
        !--- InOut
 
        Real (RK), intent(INOUT):: distribution_next(0:nx-1,0:ny-1,0:nz-1,0:lattice_in%Q)         
        !--- Local
        integer::x,y,z,k,Q_lattice

		Q_lattice=lattice_in%Q
        !print*,Q_lattice
        !pause ('Stream')
		
        do x=0,nx-1
			do y=0,ny-1
               do z=0,nz-1
				if (.not. useless(x,y,z)) then
					do k=0,Q_lattice
						distribution_next(mod(x+int(lattice_in%v_x(k))+nx,nx),mod(y+int(lattice_in%v_y(k))+ny,ny),mod(z+int(lattice_in%v_z(k))+nz,nz),k)=distribution_now(x,y,z,k)
					end do
				end if
			end do
		end do
      end do
		return
        end subroutine
		!************************
		subroutine Bounce_Back_D3Q15(distribution_now,distribution_next,lattice_in)
		implicit none
		!--- In
		type(Latice_D3Q15),intent(in):: lattice_in
        Real (RK), intent(IN):: distribution_next(0:nx-1,0:ny-1,0:nz-1,0:lattice_in%Q) 
        !--- InOut
        Real (RK), intent(INOUT):: distribution_now(0:nx-1,0:ny-1,0:nz-1,0:lattice_in%Q)  
        !--- Local
		integer::x,y,z,k,Q_lattice
		
		Q_lattice=lattice_in%Q
		do x=0,nx-1
			do y=0,ny-1
               do z=0,nz-1
				if (wall(x,y,z)) then
					do k=0,Q_lattice
						distribution_now(x,y,z,lattice_in%inv_v(k))=distribution_next(x,y,z,k)
					end do
				end if
			end do
		end do
      end do
		return
		end subroutine
		!************************
		Subroutine LB_Collision(distribution_now,distribution_next,eq_distribution,Q_lattice,info)
        implicit none
		!--- In
		type(DistroFunction) ::info
		integer, intent(IN)::Q_lattice
		Real (RK), intent(IN):: eq_distribution(0:nx-1,0:ny-1,0:nz-1,0:Q_lattice)
        Real (RK), intent(IN):: distribution_next(0:nx-1,0:ny-1,0:nz-1,0:Q_lattice)
        !--- InOut
        Real (RK), intent(INOUT):: distribution_now(0:nx-1,0:ny-1,0:nz-1,0:Q_lattice)  
         
        !--- Local
        integer::x,y,z,k
		real (RK)::tau

        !print*, Q_lattice
        !stop ('collision')
        
        
        
		tau=info%tau
        do x=0,nx-1
			do y=0,ny-1
				do z=0,nz-1
					if (.not. solid(x,y,z)) then
						do k=0,Q_lattice
							distribution_now(x,y,z,k)=distribution_next(x,y,z,k)+(eq_distribution(x,y,z,k)-distribution_next(x,y,z,k))/tau
						end do
					end if
				end do
			end do
		end do
		return
        end subroutine
        !************************
		Subroutine distribution_initialaize_D3Q15(distribution_now,distribution_next,lattice_in, ini_Val)
        implicit none
        !--- IN
        type (Latice_D3Q15), intent(IN) :: lattice_in
		real (RK):: ini_Val
        !--- IN/OUT
        real (RK), allocatable, intent(INOUT):: distribution_now(:,:,:,:), distribution_next(:,:,:,:) 
        !--- Local
        integer:: x,y,z,k,Q_lattice

		Q_lattice=lattice_in%Q
	    do x=0,nx-1
		    do y=0,ny-1
				do z=0,nz-1
					do k=0,Q_lattice
						distribution_now(x,y,z,k)=lattice_in%w_grid(k)*ini_Val
						distribution_next(x,y,z,k)=lattice_in%w_grid(k)*ini_Val
					end do
				end do
		    end do
	    end do
		return
        end subroutine
		!==============
    end module LBM